#pragma once
#include <cstdint>
#include <string>
#include <chrono>
#include <random>
#include <cartridge.h>
class CPU
{

public:
	// this is the zone where the registers are stored.
	union RegisterPair {
		struct {
			uint8_t lo;
			uint8_t hi;
		};
		uint16_t full;

		RegisterPair() : full(0) {}
	}; // this thing is for the register pairs, made to access the 16-bit regs and 8-bit regs

	enum Flag {
		FLAG_Z = 1 << 7, // Zero
		FLAG_N = 1 << 6, // Subtract
		FLAG_H = 1 << 5, // Half Carry
		FLAG_C = 1 << 4  // Carry
	}; // flag values based on the F register

	RegisterPair AF, BC, DE, HL; // registers
	uint16_t SP = 0xFFFE; // stack pointer
	uint16_t PC = 0x00; // pc, always starts at 0x100 (256 bytes)
	int ticks; // emulator ticks

	uint8_t currOpcode = 0x00; // current opcode
	int currline = 1;
	bool runningBootrom = false;
	uint16_t tempPC = 0x100;
	uint8_t tempA, tempF, tempIF, tempIE;
	uint16_t tempBC, tempDE, tempHL, tempSP;
	const uint8_t dmg_bootrom[256] = {
   0x31, 0xFE, 0xFF, 0xAF, 0x21, 0xFF, 0x9F, 0x32, 0xCB, 0x7C, 0x20, 0xFB, 0x21, 0x26, 0xFF, 0x0E,
	 0x11, 0x3E, 0x80, 0x32, 0xE2, 0x0C, 0x3E, 0xF3, 0xE2, 0x32, 0x3E, 0x77, 0x77, 0x3E, 0xFC, 0xE0,
	 0x47, 0x11, 0x04, 0x01, 0x21, 0x10, 0x80, 0x1A, 0xCD, 0x95, 0x00, 0xCD, 0x96, 0x00, 0x13, 0x7B,
	 0xFE, 0x34, 0x20, 0xF3, 0x11, 0xD8, 0x00, 0x06, 0x08, 0x1A, 0x13, 0x22, 0x23, 0x05, 0x20, 0xF9,
	 0x3E, 0x19, 0xEA, 0x10, 0x99, 0x21, 0x2F, 0x99, 0x0E, 0x0C, 0x3D, 0x28, 0x08, 0x32, 0x0D, 0x20,
	 0xF9, 0x2E, 0x0F, 0x18, 0xF3, 0x67, 0x3E, 0x64, 0x57, 0xE0, 0x42, 0x3E, 0x91, 0xE0, 0x40, 0x04,
	 0x1E, 0x02, 0x0E, 0x0C, 0xF0, 0x44, 0xFE, 0x90, 0x20, 0xFA, 0x0D, 0x20, 0xF7, 0x1D, 0x20, 0xF2,
	 0x0E, 0x13, 0x24, 0x7C, 0x1E, 0x83, 0xFE, 0x62, 0x28, 0x06, 0x1E, 0xC1, 0xFE, 0x64, 0x20, 0x06,
	 0x7B, 0xE2, 0x0C, 0x3E, 0x87, 0xE2, 0xF0, 0x42, 0x90, 0xE0, 0x42, 0x15, 0x20, 0xD2, 0x05, 0x20,
	 0x4F, 0x16, 0x20, 0x18, 0xCB, 0x4F, 0x06, 0x04, 0xC5, 0xCB, 0x11, 0x17, 0xC1, 0xCB, 0x11, 0x17,
	 0x05, 0x20, 0xF5, 0x22, 0x23, 0x22, 0x23, 0xC9, 0xCE, 0xED, 0x66, 0x66, 0xCC, 0x0D, 0x00, 0x0B,
	 0x03, 0x73, 0x00, 0x83, 0x00, 0x0C, 0x00, 0x0D, 0x00, 0x08, 0x11, 0x1F, 0x88, 0x89, 0x00, 0x0E,
	 0xDC, 0xCC, 0x6E, 0xE6, 0xDD, 0xDD, 0xD9, 0x99, 0xBB, 0xBB, 0x67, 0x63, 0x6E, 0x0E, 0xEC, 0xCC,
	 0xDD, 0xDC, 0x99, 0x9F, 0xBB, 0xB9, 0x33, 0x3E, 0x3C, 0x42, 0xB9, 0xA5, 0xB9, 0xA5, 0x42, 0x3C,
	 0x21, 0x04, 0x01, 0x11, 0xA8, 0x00, 0x1A, 0x13, 0xBE, 0x00, 0x00, 0x23, 0x7D, 0xFE, 0x34, 0x20,
	 0xF5, 0x06, 0x19, 0x78, 0x86, 0x23, 0x05, 0x20, 0xFB, 0x86, 0x00, 0x00, 0x3E, 0x01, 0xE0, 0x50
	};

	uint64_t temp_t_cycles; // temp cycles used to add to the normal t_cycles
	uint64_t t_cycles; // t cycles
	uint64_t m_cycles; // m cycles
	bool IME = false; // interrupt master enable
	bool halted = false; // halt
	bool haltBug = false; // halt bug (this is not necessary, its just for some accuracy)
	uint8_t tempff = 0xFF;


	const uint8_t nintendoLogo[0x30] = {
		0xCE, 0xED, 0x66, 0x66, 0xCC, 0x0D, 0x00, 0x0B, 0x03, 0x73, 0x00, 0x83, 0x00, 0x0C, 0x00, 0x0D,
		0x00, 0x08, 0x11, 0x1F, 0x88, 0x89, 0x00, 0x0E, 0xDC, 0xCC, 0x6E, 0xE6, 0xDD, 0xDD, 0xD9, 0x99,
		0xBB, 0xBB, 0x67, 0x63, 0x6E, 0x0E, 0xEC, 0xCC, 0xDD, 0xDC, 0x99, 0x9F, 0xBB, 0xB9, 0x33, 0x3E
	}; // nintendo logo used to compare to the rom's one

	std::string logdata = "";




	void initializeGameboy();
	void Push16(uint16_t value); // push 16-bytes to stack
	uint16_t Read16(uint16_t addr); // read 16-bit byte from memory

	std::string byteToHexString(uint8_t value);
	std::string wordToHexString(uint16_t value);

	void ExecuteInstruction(uint8_t opcode); // execute cpu opcodes



	void halt(); // halt cpu


	CPU();
	void Cycle(); // cpu cycle
	~CPU();
};



extern CPU cpu;